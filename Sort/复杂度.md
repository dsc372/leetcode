排序方法	时间复杂度(平均)	时间复杂度(最坏)	时间复杂度(最好)	空间复杂度	稳定性
冒泡排序	O(n²)	O(n²)	O(n)	O(1)	稳定
选择排序	O(n²)	O(п²)	O(n²)	O(1)	不稳定
插入排序	O(n²)	O(n²)	O(n)	O(1)	稳定
归并排序	O(nlog₂n)	O(nlog₂n)	O(nlog₂n)	O(n)	稳定
快速排序	O(nlog₂n)	O(n²)	O(nlog₂n)	O(nlog₂n)	不稳定


Array.prototype.sort 数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort


# 快速排序优化
‌快速排序的优化主要包括改进‌基准值的选择策略、处理小规模子数组以及通过特定的分区策略来减少递归调用的次数。具体如下：‌
## 优化基准值的选择
通过三数取中法选择基准值，即先从数组中随机选择三个元素，对它们进行排序后取中间值作为基准，这样可以减少因极端基准值选择导致的不均匀分区，从而降低最坏情况下的时间复杂度。‌
## 处理小规模子数组
当子数组规模较小时（例如小于等于8个元素），改用插入排序，因为此时插入排序的效率高于快速排序。这种策略结合了两种排序算法的优势，提高了整体性能。‌
## 特定的分区策略采用三分区策略
即将元素分为三组：小于基准值、等于基准值、大于基准值。这样可以将等于基准值的元素放在一边，减少递归排序的范围，从而可能使快速排序成为稳定的排序算法。
## 单边递归优化
在分区完成后，只对非空的一侧进行递归排序，这样可以减少递归调用的次数，进而减少函数调用的开销，提高算法效率。‌